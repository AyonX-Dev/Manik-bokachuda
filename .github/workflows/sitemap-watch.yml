name: Sitemap → Decode → GitHub + Telegram (final, stable)

on:
  schedule:
    - cron: '0 1 * * *'    # daily 01:00 UTC (change if needed)
  workflow_dispatch:

jobs:
  watch:
    runs-on: ubuntu-latest
    env:
      SITEMAP_URL: "https://www.streamecho.top/sitemap.xml"
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup utilities & Python
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq
          python -m pip install --upgrade pip
          pip install --upgrade requests beautifulsoup4
        shell: bash

      - name: Ensure tracker files exist (repo)
        run: |
          [ -f sitemap_urls.txt ] || echo "# sitemap urls collected by actions" > sitemap_urls.txt
          [ -f found_playlists.txt ] || echo "# found playlist urls" > found_playlists.txt
          [ -f chat_ids.txt ] || echo "# chat ids collected by actions" > chat_ids.txt
          [ -f sent_log.txt ] || echo "# sent log: chatid|postid|unix_ts" > sent_log.txt
          [ -f blocked_chats.txt ] || echo "# blocked chat ids (permanent failures)" > blocked_chats.txt
          git add sitemap_urls.txt found_playlists.txt chat_ids.txt sent_log.txt blocked_chats.txt || true
          git commit -m "chore: add tracker files (init)" || true
        shell: bash

      - name: Run sitemap processor (latest N=5)
        run: |
          echo "[*] Running process_sitemap.py (latest 5)"
          python3 scripts/process_sitemap.py --sitemap "${{ env.SITEMAP_URL }}" --tracked-file sitemap_urls.txt --playlists-file found_playlists.txt --out /tmp/new_posts.txt --max-check 5
          echo "[*] Preview /tmp/new_posts.txt (if any):"
          [ -f /tmp/new_posts.txt ] && sed -n '1,200p' /tmp/new_posts.txt || echo "no new posts"
          [ -f /tmp/decoded_results.json ] && jq -C . /tmp/decoded_results.json || echo "no decoded_results.json"
        shell: bash

      - name: Commit decoded results (if any) & keep decoded artifact
        id: commit_decoded
        run: |
          if [ -s /tmp/new_posts.txt ]; then
            cp /tmp/new_posts.txt decoded_results.txt
            if [ -f /tmp/decoded_results.json ]; then cp /tmp/decoded_results.json decoded_results.json; fi
            git add sitemap_urls.txt found_playlists.txt decoded_results.txt decoded_results.json || true
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            if git diff --staged --quiet; then
              echo "no_changes=true" > /tmp/commit_decoded_result.txt
            else
              git commit -m "chore: add discovered playlist posts (auto)" || true
              # push if token provided otherwise normal push (will fail if no permissions)
              if [ -n "${{ secrets.PUSH_TOKEN || '' }}" ]; then
                git remote set-url origin https://x-access-token:${{ secrets.PUSH_TOKEN }}@github.com/${{ github.repository }}.git
                git push origin HEAD || true
              else
                git push origin HEAD || true
              fi
              echo "no_changes=false" > /tmp/commit_decoded_result.txt
            fi
          else
            echo "no_new_posts" > /tmp/commit_decoded_result.txt
          fi
          cat /tmp/commit_decoded_result.txt
        shell: bash

      - name: Upload decoded_results artifact (if present)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: decoded-results
          path: |
            /tmp/decoded_results.json
            /tmp/new_posts.txt
            decoded_results.txt
            decoded_results.json

      - name: Auto-capture chat IDs from getUpdates (delete webhook if set; collect ALL types)
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        run: |
          set -euo pipefail
          TOKEN="${TELEGRAM_BOT_TOKEN}"
          CHATFILE="chat_ids.txt"
          UFILE="/tmp/updates.json"

          echo "[*] Checking webhook status..."
          wh_info=$(curl -s "https://api.telegram.org/bot${TOKEN}/getWebhookInfo" || echo "{}")
          wh_url=$(jq -r '.result.url // empty' <<<"$wh_info" 2>/dev/null || echo "")

          if [ -n "$wh_url" ]; then
            echo "[*] Webhook detected — deleting to allow getUpdates."
            curl -s -X POST "https://api.telegram.org/bot${TOKEN}/deleteWebhook" > /tmp/deletewh.json || true
            cat /tmp/deletewh.json || true
            sleep 1
          else
            echo "[*] No webhook set — using getUpdates."
          fi

          echo "[*] Fetching updates..."
          curl -s "https://api.telegram.org/bot${TOKEN}/getUpdates" > ${UFILE} || true

          echo "[*] Extracting IDs..."
          jq -r '
            .result[]? |
            (
              .message.chat.id?,
              .edited_message.chat.id?,
              .channel_post.chat.id?,
              .edited_channel_post.chat.id?,
              .my_chat_member.chat.id?,
              .chat_member.chat.id?,
              .callback_query.message.chat.id?,
              .callback_query.from.id?,
              .inline_query.from.id?,
              .pre_checkout_query.from.id?,
              .shipping_query.from.id?,
              .poll_answer.user.id?
            )
          ' ${UFILE} | grep -v null | sort -u | tr -d '\r' > /tmp/all_ids.txt || true

          echo "[*] IDs discovered:"
          sed -n '1,200p' /tmp/all_ids.txt || true

          # Append new IDs to chat_ids.txt (preserve order)
          added=0
          while IFS= read -r id; do
            id="$(echo "$id" | tr -d '\r' | xargs)"
            [ -z "$id" ] && continue
            if grep -Fqx -- "$id" "$CHATFILE"; then
              echo "exists: $id"
            else
              echo "$id" >> "$CHATFILE"
              echo "added new chat id: $id"
              added=$((added+1))
            fi
          done < /tmp/all_ids.txt

          # Dedupe & keep first occurrence
          awk '!seen[$0]++' "$CHATFILE" > /tmp/chat_ids.tmp && mv /tmp/chat_ids.tmp "$CHATFILE"

          # Commit chat_ids.txt only if updated
          if [ $added -gt 0 ]; then
            git add "$CHATFILE" || true
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git commit -m "chore: update chat_ids (auto)" || true
            if [ -n "${{ secrets.PUSH_TOKEN || '' }}" ]; then
              git remote set-url origin https://x-access-token:${{ secrets.PUSH_TOKEN }}@github.com/${{ github.repository }}.git
              git push origin HEAD || true
            else
              git push origin HEAD || true
            fi
          else
            echo "[*] chat_ids unchanged"
          fi
        shell: bash

      - name: Broadcast (stable: single attempt, block permanent, queue transient)
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        run: |
          set -euo pipefail
          TOKEN="${TELEGRAM_BOT_TOKEN}"
          CHATFILE="chat_ids.txt"
          BLOCKFILE="blocked_chats.txt"
          SENTLOG="sent_log.txt"
          RETRYQ="/tmp/retry_queue.json"
          JSON="/tmp/decoded_results.json"
          LOCK="/tmp/sent_log.lock"

          [ -f "$BLOCKFILE" ] || echo "# blocked chat ids" > "$BLOCKFILE"
          [ -f "$SENTLOG" ] || echo "# sent log: chatid|postid|unix_ts" > "$SENTLOG"
          [ -f "$RETRYQ" ] || echo "[]" > "$RETRYQ"

          is_valid_url(){ printf '%s' "$1" | grep -E -q '^https?://'; }

          if [ ! -s "$JSON" ]; then
            echo "[*] No decoded results to broadcast; exit"
            exit 0
          fi

          mapfile -t ALL_CIDS < <(grep -vE '^\s*#|^\s*$' "$CHATFILE" || true)
          for i in "${!ALL_CIDS[@]}"; do
            ALL_CIDS[$i]=$(echo "${ALL_CIDS[$i]}" | tr -d '\r' | xargs)
          done
          echo "[*] total chat ids to attempt:" "${#ALL_CIDS[@]}"

          # iterate posts
          jq -c '.[]' "$JSON" | while read -r item; do
            title=$(jq -r '.title // ""' <<<"$item")
            thumb=$(jq -r '.thumbnail // ""' <<<"$item")
            link=$(jq -r '.playlist // ""' <<<"$item")
            postid="$link"
            caption=$(printf "%s\n%s" "$title" "$link")

            for cid in "${ALL_CIDS[@]}"; do
              cid=$(echo "$cid" | tr -d '\r' | xargs)
              [ -z "$cid" ] && continue

              # skip blocked
              if grep -Fxq -- "$cid" "$BLOCKFILE"; then
                echo "[skip blocked] $cid"
                continue
              fi

              # skip already sent
              if grep -Fqx -- "${cid}|${postid}" "$SENTLOG"; then
                echo "[skip sent] $cid -> $postid"
                continue
              fi

              echo "[*] Sending to: ${cid} (post: ${postid})"

              # single attempt
              if [ -n "$thumb" ] && is_valid_url "$thumb"; then
                resp=$(curl -s -m 20 -X POST "https://api.telegram.org/bot${TOKEN}/sendPhoto" \
                  -d chat_id="$cid" --data-urlencode "photo=$thumb" --data-urlencode "caption=$caption")
              else
                resp=$(curl -s -m 20 -X POST "https://api.telegram.org/bot${TOKEN}/sendMessage" \
                  -d chat_id="$cid" --data-urlencode "text=$caption")
              fi

              echo "$resp" > "/tmp/last_send_resp_${cid}.json" || true
              ok=$(jq -r '.ok // false' "/tmp/last_send_resp_${cid}.json" 2>/dev/null || echo "false")
              errcode=$(jq -r '.error_code // 0' "/tmp/last_send_resp_${cid}.json" 2>/dev/null || echo "0")
              desc=$(jq -r '.description // ""' "/tmp/last_send_resp_${cid}.json" 2>/dev/null || echo "")

              if [ "$ok" = "true" ]; then
                echo "${cid}|${postid}|$(date +%s)" >> "$SENTLOG"
                echo "[ok] $cid -> $postid"
              else
                echo "[fail] $cid -> $postid ; code:$errcode ; $desc"
                # transient -> queue for retry later
                if [ "$errcode" = "429" ] || ( [ "$errcode" -ge 500 ] 2>/dev/null ); then
                  jq --arg cid "$cid" --arg post "$postid" --arg now "$(date +%s)" \
                    '. + [{cid:$cid,post:$post,ts:$now}]' "$RETRYQ" > "${RETRYQ}.tmp" && mv "${RETRYQ}.tmp" "$RETRYQ"
                  echo "[queued retry] $cid"
                else
                  # permanent -> block
                  if ! grep -Fxq -- "$cid" "$BLOCKFILE"; then
                    echo "$cid" >> "$BLOCKFILE"
                    echo "[blocked] $cid (reason: $desc)"
                  fi
                fi
              fi

              sleep 0.8
            done
          done

          # upload retry queue artifact for retry worker
          if [ -s "$RETRYQ" ]; then
            echo "[*] Uploading retry_queue.json artifact"
          fi
        shell: bash

      - name: Upload artifacts (chat_ids, sent_log, blocked_chats, retry_queue)
        uses: actions/upload-artifact@v4
        with:
          name: run-state
          path: |
            chat_ids.txt
            sent_log.txt
            blocked_chats.txt
            /tmp/retry_queue.json
            /tmp/decoded_results.json

  retry-worker:
    needs: watch
    runs-on: ubuntu-latest
    if: always()
    env:
      # need TELEGRAM_BOT_TOKEN in secrets
      RETRY_AGE_SECONDS: 86400   # only retry items younger than this (default 24h)
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup utils
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq
        shell: bash

      - name: Download run-state artifacts
        uses: actions/download-artifact@v4
        with:
          name: run-state
          path: /tmp/run-state

      - name: Prepare files for retry job
        run: |
          # copy back to workspace paths
          cp /tmp/run-state/chat_ids.txt ./chat_ids.txt || true
          cp /tmp/run-state/sent_log.txt ./sent_log.txt || true
          cp /tmp/run-state/blocked_chats.txt ./blocked_chats.txt || true
          cp /tmp/run-state/retry_queue.json /tmp/retry_queue.json || echo "[]" > /tmp/retry_queue.json
          [ -f /tmp/retry_queue.json ] || echo "[]" > /tmp/retry_queue.json
          echo "Retry queue size:"
          jq '. | length' /tmp/retry_queue.json || echo "0"
        shell: bash

      - name: Retry transient failures (process retry_queue.json)
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          PUSH_TOKEN: ${{ secrets.PUSH_TOKEN || '' }}
        run: |
          set -euo pipefail
          TOKEN="${TELEGRAM_BOT_TOKEN}"
          RETRYQ="/tmp/retry_queue.json"
          NEWQ="/tmp/retry_queue_new.json"
          SENTLOG="sent_log.txt"
          BLOCKFILE="blocked_chats.txt"
          CHATFILE="chat_ids.txt"

          [ -f "$SENTLOG" ] || echo "# sent log: chatid|postid|unix_ts" > "$SENTLOG"
          [ -f "$BLOCKFILE" ] || echo "# blocked chat ids" > "$BLOCKFILE"
          [ -f "$CHATFILE" ] || echo "# chat ids" > "$CHATFILE"

          is_valid_url(){ printf '%s' "$1" | grep -E -q '^https?://'; }

          # start new queue as original
          jq '.' "$RETRYQ" > "$NEWQ" || echo "[]" > "$NEWQ"

          tmpcount=$(jq '. | length' "$RETRYQ" 2>/dev/null || echo 0)
          if [ "$tmpcount" -eq 0 ]; then
            echo "[*] No retry items; nothing to do."
            exit 0
          fi

          # Process each item; items: {cid, post, ts}
          jq -c '.[]' "$RETRYQ" | while read -r item; do
            cid=$(jq -r '.cid' <<<"$item")
            post=$(jq -r '.post' <<<"$item")
            ts=$(jq -r '.ts' <<<"$item")
            now=$(date +%s)
            age=$((now - ts))

            # skip old items
            if [ "$age" -gt "$RETRY_AGE_SECONDS" ]; then
              echo "[skip old] $cid -> $post (age ${age}s)"
              # remove this item by filtering later (we'll reconstruct)
              jq -n --arg cid "$cid" --arg post "$post" '{"cid":$cid,"post":$post,"ts":'$ts'}' >/dev/null
              # do not attempt
              continue
            fi

            # skip if blocked already
            if grep -Fxq -- "$cid" "$BLOCKFILE"; then
              echo "[skip blocked] $cid"
              continue
            fi

            # skip if already sent
            if grep -Fqx -- "${cid}|${post}" "$SENTLOG"; then
              echo "[skip sent] $cid -> $post"
              continue
            fi

            echo "[retry] trying $cid -> $post"

            # attempt send (single try)
            resp=$(curl -s -m 20 -X POST "https://api.telegram.org/bot${TOKEN}/sendMessage" \
              -d chat_id="$cid" --data-urlencode "text=${post}")
            echo "$resp" > "/tmp/last_retry_resp_${cid}.json" || true
            ok=$(jq -r '.ok // false' "/tmp/last_retry_resp_${cid}.json" 2>/dev/null || echo "false")
            errcode=$(jq -r '.error_code // 0' "/tmp/last_retry_resp_${cid}.json" 2>/dev/null || echo "0")
            desc=$(jq -r '.description // ""' "/tmp/last_retry_resp_${cid}.json" 2>/dev/null || echo "")

            if [ "$ok" = "true" ]; then
              echo "${cid}|${post}|$(date +%s)" >> "$SENTLOG"
              echo "[ok retry] $cid -> $post"
              # remove this item from NEWQ
              jq --arg cid "$cid" --arg post "$post" 'map(select(.cid != $cid or .post != $post))' "$NEWQ" > "${NEWQ}.tmp" && mv "${NEWQ}.tmp" "$NEWQ"
            else
              echo "[retry fail] $cid -> $post ; code:$errcode ; $desc"
              if [ "$errcode" = "429" ] || ( [ "$errcode" -ge 500 ] 2>/dev/null ); then
                echo "[retry queued again] $cid"
                # keep item in NEWQ unchanged
              else
                # permanent -> block
                if ! grep -Fxq -- "$cid" "$BLOCKFILE"; then
                  echo "$cid" >> "$BLOCKFILE"
                  echo "[blocked (retry)] $cid (reason: $desc)"
                fi
                # remove from NEWQ
                jq --arg cid "$cid" --arg post "$post" 'map(select(.cid != $cid or .post != $post))' "$NEWQ" > "${NEWQ}.tmp" && mv "${NEWQ}.tmp" "$NEWQ"
              fi
            fi

            sleep 1
          done

          # write back new retry queue
          mv "$NEWQ" "$RETRYQ" || true
          echo "[*] remaining retry items:" $(jq '.|length' "$RETRYQ" 2>/dev/null || echo 0)

          # Commit updated sent_log and blocked_chats (optional - recommended)
          git add "$SENTLOG" "$BLOCKFILE" || true
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          if ! git diff --staged --quiet; then
            git commit -m "chore: update sent_log/blocked_chats (retry worker)" || true
            if [ -n "${PUSH_TOKEN:-}" ]; then
              git remote set-url origin https://x-access-token:${PUSH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git
              git push origin HEAD || true
            else
              git push origin HEAD || true
            fi
          else
            echo "[*] nothing to commit from retry worker"
          fi
        shell: bash

      - name: Upload final run artefacts
        uses: actions/upload-artifact@v4
        with:
          name: final-state
          path: |
            sent_log.txt
            blocked_chats.txt
            /tmp/retry_queue.json

      - name: Final status
        run: |
          echo "Retry worker finished. Inspect sent_log.txt and blocked_chats.txt"
        shell: bash
