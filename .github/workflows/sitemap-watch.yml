name: Sitemap → Decode → GitHub + Telegram (stable, trimmed)

on:
  schedule:
    - cron: '0 1 * * *'    # daily 01:00 UTC (change if needed)
  workflow_dispatch:

env:
  SITEMAP_URL: "https://www.streamecho.top/sitemap.xml"
  # TELEGRAM_BOT_TOKEN must be set in repository secrets
  # optional PUSH_TOKEN in secrets if you want to push updates non-interactively

jobs:
  watch:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install utilities & Python
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq
          python -m pip install --upgrade pip
        shell: bash

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install python deps
        run: |
          pip install --upgrade requests beautifulsoup4
        shell: bash

      - name: Ensure tracker files exist (minimal)
        run: |
          [ -f sitemap_urls.txt ] || echo "# sitemap urls collected by actions" > sitemap_urls.txt
          [ -f found_playlists.txt ] || echo "# found playlist urls" > found_playlists.txt
          [ -f chat_ids.txt ] || echo "# chat ids collected by actions" > chat_ids.txt
          [ -f blocked_chats.txt ] || echo "# blocked chat ids (permanent errors)" > blocked_chats.txt
          [ -f sent_log.txt ] || echo "# sent log: chatid|postid|unix_ts" > sent_log.txt
          [ -f /tmp/retry_queue.json ] || echo "[]" > /tmp/retry_queue.json
        shell: bash

      - name: Run sitemap processor (check latest 5)
        run: |
          echo "[*] Running process_sitemap.py (latest 5)"
          python3 scripts/process_sitemap.py --sitemap "${{ env.SITEMAP_URL }}" --tracked-file sitemap_urls.txt --playlists-file found_playlists.txt --out /tmp/new_posts.txt --max-check 5
          echo "[*] Preview new_posts (first 200 lines):"
          [ -f /tmp/new_posts.txt ] && sed -n '1,200p' /tmp/new_posts.txt || echo "no new_posts"
          echo "[*] Preview decoded_results.json (if exists):"
          [ -f /tmp/decoded_results.json ] && jq -C . /tmp/decoded_results.json || echo "no decoded_results.json"
        shell: bash

      - name: Auto-capture chat IDs from getUpdates (delete webhook if set; collect ALL types)
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        run: |
          set -euo pipefail
          TOKEN="${TELEGRAM_BOT_TOKEN}"
          CHATFILE="chat_ids.txt"
          UFILE="/tmp/updates.json"

          echo "[*] Checking webhook status..."
          wh_info=$(curl -s "https://api.telegram.org/bot${TOKEN}/getWebhookInfo" || echo "{}")
          wh_url=$(jq -r '.result.url // empty' <<<"$wh_info" 2>/dev/null || echo "")

          if [ -n "$wh_url" ]; then
            echo "[*] Webhook detected — deleting to allow getUpdates."
            curl -s -X POST "https://api.telegram.org/bot${TOKEN}/deleteWebhook" > /tmp/deletewh.json || true
            cat /tmp/deletewh.json || true
            sleep 1
          else
            echo "[*] No webhook set — using getUpdates."
          fi

          echo "[*] Fetching updates..."
          curl -s "https://api.telegram.org/bot${TOKEN}/getUpdates" > ${UFILE} || true

          echo "[*] Extracting IDs..."
          jq -r '
            .result[]? |
            (
              .message.chat.id?,
              .edited_message.chat.id?,
              .channel_post.chat.id?,
              .edited_channel_post.chat.id?,
              .my_chat_member.chat.id?,
              .chat_member.chat.id?,
              .callback_query.message.chat.id?,
              .callback_query.from.id?,
              .inline_query.from.id?,
              .pre_checkout_query.from.id?,
              .shipping_query.from.id?,
              .poll_answer.user.id?
            )
          ' ${UFILE} | grep -v null | sort -u | tr -d '\r' > /tmp/all_ids.txt || true

          echo "[*] IDs discovered:"
          sed -n '1,200p' /tmp/all_ids.txt || true

          # Append new IDs to chat_ids.txt (preserve order)
          added=0
          while IFS= read -r id; do
            id="$(echo "$id" | tr -d '\r' | xargs)"
            [ -z "$id" ] && continue
            if grep -Fqx -- "$id" "$CHATFILE"; then
              echo "exists: $id"
            else
              echo "$id" >> "$CHATFILE"
              echo "added new chat id: $id"
              added=$((added+1))
            fi
          done < /tmp/all_ids.txt

          # dedupe and keep first occurrence
          awk '!seen[$0]++' "$CHATFILE" > /tmp/chat_ids.tmp && mv /tmp/chat_ids.tmp "$CHATFILE"

          # commit only chat_ids.txt if changed (minimize pushes)
          if [ $added -gt 0 ]; then
            git add "$CHATFILE" || true
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git commit -m "chore: update chat_ids (auto)" || true
            if [ -n "${{ secrets.PUSH_TOKEN || '' }}" ]; then
              # use push token if provided
              git remote set-url origin https://x-access-token:${{ secrets.PUSH_TOKEN }}@github.com/${{ github.repository }}.git
              git push origin HEAD || true
            else
              git push origin HEAD || true
            fi
          else
            echo "[*] chat_ids unchanged (no commit)"
          fi
        shell: bash

      - name: Broadcast (stable/minimal: single attempt; block permanent; queue transient)
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        run: |
          set -euo pipefail
          TOKEN="${TELEGRAM_BOT_TOKEN}"
          CHATFILE="chat_ids.txt"
          BLOCKFILE="blocked_chats.txt"
          SENTLOG="sent_log.txt"
          RETRYQ="/tmp/retry_queue.json"
          JSON="/tmp/decoded_results.json"

          [ -f "$BLOCKFILE" ] || echo "# blocked chat ids" > "$BLOCKFILE"
          [ -f "$SENTLOG" ] || echo "# chatid|postid|unix_ts" > "$SENTLOG"
          [ -f "$RETRYQ" ] || echo "[]" > "$RETRYQ"

          is_valid_url(){ printf '%s' "$1" | grep -E -q '^https?://'; }

          if [ ! -s "$JSON" ]; then
            echo "[*] No decoded results to broadcast; exit"
            exit 0
          fi

          mapfile -t ALL_CIDS < <(grep -vE '^\s*#|^\s*$' "$CHATFILE" || true)
          for i in "${!ALL_CIDS[@]}"; do
            ALL_CIDS[$i]=$(echo "${ALL_CIDS[$i]}" | tr -d '\r' | xargs)
          done
          echo "[*] total chat ids to attempt:" "${#ALL_CIDS[@]}"

          jq -c '.[]' "$JSON" | while read -r item; do
            title=$(jq -r '.title // ""' <<<"$item")
            thumb=$(jq -r '.thumbnail // ""' <<<"$item")
            link=$(jq -r '.playlist // ""' <<<"$item")
            postid="$link"
            caption=$(printf "%s\n%s" "$title" "$link")

            for cid in "${ALL_CIDS[@]}"; do
              cid=$(echo "$cid" | tr -d '\r' | xargs)
              [ -z "$cid" ] && continue

              # skip blocked ids
              if grep -Fxq "$cid" "$BLOCKFILE"; then
                echo "[skip blocked] $cid"
                continue
              fi

              # skip already sent
              if grep -Fqx -- "${cid}|${postid}" "$SENTLOG"; then
                echo "[skip sent] $cid -> $postid"
                continue
              fi

              echo "[*] Sending to: ${cid} (post: ${postid})"

              # single attempt
              if [ -n "$thumb" ] && is_valid_url "$thumb"; then
                resp=$(curl -s -m 20 -X POST "https://api.telegram.org/bot${TOKEN}/sendPhoto" \
                  -d chat_id="$cid" --data-urlencode "photo=$thumb" --data-urlencode "caption=$caption")
              else
                resp=$(curl -s -m 20 -X POST "https://api.telegram.org/bot${TOKEN}/sendMessage" \
                  -d chat_id="$cid" --data-urlencode "text=$caption")
              fi

              echo "$resp" > "/tmp/last_send_resp_${cid}.json" || true
              ok=$(jq -r '.ok // false' "/tmp/last_send_resp_${cid}.json" 2>/dev/null || echo "false")
              errcode=$(jq -r '.error_code // 0' "/tmp/last_send_resp_${cid}.json" 2>/dev/null || echo "0")
              desc=$(jq -r '.description // ""' "/tmp/last_send_resp_${cid}.json" 2>/dev/null || echo "")

              if [ "$ok" = "true" ]; then
                echo "${cid}|${postid}|$(date +%s)" >> "$SENTLOG"
                echo "[ok] $cid -> $postid"
              else
                echo "[fail] $cid -> $postid ; code:$errcode ; $desc"
                # transient -> append to retry queue
                if [ "$errcode" = "429" ] || ( [ "$errcode" -ge 500 ] 2>/dev/null ); then
                  jq --arg cid "$cid" --arg post "$postid" --arg now "$(date +%s)" \
                    '. + [{cid:$cid,post:$post,ts:$now}]' "$RETRYQ" > "${RETRYQ}.tmp" && mv "${RETRYQ}.tmp" "$RETRYQ"
                  echo "[queued retry] $cid"
                else
                  # permanent error: block the chat id
                  if ! grep -Fxq "$cid" "$BLOCKFILE"; then
                    echo "$cid" >> "$BLOCKFILE"
                    echo "[blocked] $cid (reason: $desc)"
                  fi
                fi
              fi

              sleep 0.8
            done
          done

          echo "[*] Broadcast finished. Sent-log lines:"
          tail -n 20 "$SENTLOG" || true
        shell: bash

      - name: Final status
        run: |
          echo "Workflow finished. If there are transient failures they are queued in /tmp/retry_queue.json"
        shell: bash
